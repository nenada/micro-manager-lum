// Recursion speed test with hardware control
// The script sends commands to arduino to switch channels and drive the camera
// Assumes we are using the configuration "targa-rcr.cfg"

numberOfSites = 10;
cameraExposureMs = 1.0;
colors = new String[] {"RED", "GREEN", "CYAN"};
intensities = new int[] {500, 500, 700};
ttlExposuresMs = new double[] {1, 1, 1};
zPos = new double[] {0.0, -5.0, 5.0}; // TODO: snake
ttlDevice = "TTLSwitch";
xyStage = mmc.getXYStageDevice();
zStage = mmc.getFocusDevice();
camera = mmc.getCameraDevice();

// run xy stage in a 2.25 mm well pitch square
xPos = new double[] {2250, 0.0, -2250, 0.0};
yPos = new double[] {0.0, 2250, 0.0, -2250};

// Program the Arduino
startT = java.lang.System.currentTimeMillis();
sequenceCmd = new java.lang.StringBuilder();
for (i=0; i<colors.length; i++) {
	sequenceCmd.append(colors[i]).append(" ");
	mmc.setProperty(ttlDevice, colors[i] + "_Intensity", intensities[i]);
	mmc.setProperty(ttlDevice, colors[i] + "_ExposureMs", ttlExposuresMs[i]);
}
mmc.setProperty(ttlDevice, "ChannelSequence", sequenceCmd.toString());
progArdTime = java.lang.System.currentTimeMillis() - startT;
print("Programming TTL sequence took [ms]: " + progArdTime);  

// move stage and acquire images
// TODO: save images to dataset on disk
print("Starting the acquisition, please wait for up to 20 sec...");
mmc.setXYPosition(xyStage, 0.0, 0.0);
mmc.waitForDevice(xyStage);

// set the camera in sequence mode with external exposure control
mmc.setConfig("CameraMode", "Sequence");

// start the camera
mmc.clearCircularBuffer();
mmc.startContinuousSequenceAcquisition(0);

// iterate over sites
for (i=0; i<numberOfSites; i++) {
	print("\nSite " + (i + 1));
	// move to well
	startT = java.lang.System.currentTimeMillis();
	mmc.setXYPosition(xPos[i%4], yPos[i%4]);
	mmc.waitForDevice(xyStage);
	xyMoveT = java.lang.System.currentTimeMillis() - startT;
	print("\tXY move [ms]: " + xyMoveT);
	stackTotalT = 0.0;
	imageStackTotalT = 0.0;
	
	for (f=0; f<zPos.length; f++) {
		startT = java.lang.System.currentTimeMillis();
		mmc.setPosition(zStage, zPos[f]);
		mmc.waitForDevice(zStage);
		zMoveT = java.lang.System.currentTimeMillis() - startT;
		print("\t\tZ move [ms]: " + zMoveT);
		stackTotalT += zMoveT;
	
		// take images
      startTImg = java.lang.System.currentTimeMillis();
      mmc.setProperty(ttlDevice, "RunSequence", "1"); // this sends GO cammand to TTLSwitch

      // wait for the images to be acquired
      int retries = 0;
      int maxRetries = 10;
      while (mmc.getRemainingImageCount() < colors.length && retries < maxRetries) {
         mmc.sleep(10);
         retries++;
      }
      if (retries >= maxRetries) {
      	print("Error: timeout waiting for images");
         break;
      }

      // retrieve images
		for (c=0; c<colors.length; c++) {
			img = mmc.popNextImage();
            // TODO: save image to disk
		}
		imageStackTotalT = java.lang.System.currentTimeMillis() - startTImg;;
		print("\t\tImagex3 [ms]: " + imageStackTotalT);
	}
	print("\tZ stack [ms]: " + stackTotalT);
	print("\t=====");
	print("\timaging [ms]: " + imageStackTotalT);
	print("\tmotion [ms]: " + (xyMoveT + stackTotalT));
	print("\tSite time [ms]: " + (imageStackTotalT + xyMoveT + stackTotalT));
}

print("Please wait, stopping the camera (may take a minute)...");
mmc.stopSequenceAcquisition();
mmc.setConfig("CameraMode", "Standard");


print("Done.");